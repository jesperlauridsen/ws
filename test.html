<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Three.js — Saturn Rings Shader (Random Spacing + Pulsing Glow)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        left: 16px;
        top: 16px;
        color: #fff;
        font-family:
          system-ui,
          -apple-system,
          Roboto,
          'Segoe UI',
          'Helvetica Neue',
          Arial;
        background: rgba(0, 0, 0, 0.35);
        padding: 10px;
        border-radius: 8px;
        backdrop-filter: blur(4px);
      }
      label {
        font-size: 13px;
        display: block;
        margin-bottom: 6px;
      }
      input[type='range'] {
        width: 220px;
      }
      .row {
        margin-bottom: 8px;
      }
      .credits {
        font-size: 11px;
        opacity: 0.85;
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div class="row">
        <label>Ring count: <span id="rc">8</span></label>
        <input id="ringCount" type="range" min="1" max="16" value="8" />
      </div>
      <div class="row">
        <label>Line width: <span id="lw">0.008</span></label>
        <input id="lineWidth" type="range" min="1" max="30" value="8" />
      </div>
      <div class="row">
        <label>Noise strength: <span id="ns">0.02</span></label>
        <input id="noiseStrength" type="range" min="0" max="50" value="2" />
      </div>
      <div class="credits">Drag to orbit • Scroll to zoom • UI updates shader uniforms</div>
    </div>

    <script type="module">
      import * as THREE from 'https://esm.run/three@0.152.2';
      import { OrbitControls } from 'https://esm.run/three@0.152.2/examples/jsm/controls/OrbitControls.js';
      import { EffectComposer } from 'https://esm.run/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://esm.run/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'https://esm.run/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 2.6, 6.0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 2.5;
      controls.maxDistance = 20;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 0.6));

      // --- Flat circular ring plane ---
      const outerRadius = 2.2,
        innerRadius = 1.3,
        segments = 256;
      const geometry = new THREE.CircleGeometry(outerRadius, segments);
      geometry.rotateX(-Math.PI / 2);

      const positions = geometry.attributes.position.array;
      const newPositions = [];
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i],
          z = positions[i + 2];
        const r = Math.sqrt(x * x + z * z);
        if (r >= innerRadius) newPositions.push(x, positions[i + 1], z);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      geometry.computeVertexNormals();

      // --- Shader ---
      const MAX_RINGS = 16;
      const vertexShader = `
        varying vec3 vPos;
        void main(){ vPos = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `;

      const fragmentShader = `
        #define MAX_RINGS ${MAX_RINGS}
        precision highp float;
        varying vec3 vPos;
        uniform int uRingCount;
        uniform vec3 uRingColors[MAX_RINGS];
        uniform float uLineWidth;
        uniform float uNoiseStrength;
        uniform float uTime;
        uniform float uPulseSpeeds[MAX_RINGS];
        uniform float uRingOffsets[MAX_RINGS];

        float hash(float n){return fract(sin(n)*43758.5453123);}
        float noise1(float x){ float i=floor(x); float f=fract(x); float a=hash(i); float b=hash(i+1.0); float u=f*f*(3.0-2.0*f); return mix(a,b,u);}
        float softPulse(float d,float w){ float x=d/w; return exp(-x*x*6.0); }

        void main(){
          float r = length(vPos.xz);
          float tRadial = (r - ${innerRadius.toFixed(2)}) / (${(outerRadius - innerRadius).toFixed(2)});
          tRadial = clamp(tRadial,0.0,1.0);

          vec3 col=vec3(0.0);
          float alpha=0.0;
          float angle=atan(vPos.z,vPos.x);
          float nx=cos(angle*3.0), ny=sin(angle*3.0);

          for(int i=0;i<MAX_RINGS;i++){
            if(i>=uRingCount) break;

            float t = uRingOffsets[i]; // random radial offset per ring
            float n = (noise1(tRadial*120.0+float(i)*17.3+uTime*0.15)-0.5)*uNoiseStrength;
            float dist = abs(tRadial-(t+n));

            float glowNoise = noise1(nx*10.0 + ny*10.0 + float(i)*13.7);
            float pulse = 0.5 + 0.5*sin(uTime*uPulseSpeeds[i] + glowNoise*6.2831);

            float base = smoothstep(uLineWidth,0.0,dist);
            float glow = softPulse(dist,uLineWidth*8.0)*0.5*pulse;

            vec3 rc = uRingColors[i];
            col += rc*(base+glow);
            alpha += (base+glow);
          }

          alpha=clamp(alpha,0.0,1.0);
          gl_FragColor=vec4(col,alpha);
        }
      `;

      // --- Colors + pulse speeds + random offsets ---
      const palette = [
        '#cfa36b',
        '#b97a3a',
        '#f6e7c9',
        '#8b5a3c',
        '#e6b38a',
        '#f6f0e6',
        '#9e6b4d',
        '#d8c2a3',
      ];
      const ringColors = [],
        pulseSpeeds = [],
        ringOffsets = [];
      for (let i = 0; i < MAX_RINGS; i++) {
        const c = new THREE.Color(palette[i % palette.length]);
        c.offsetHSL(i * 0.02 - 0.08, i % 2 ? -0.02 : 0.02, 0.0);
        ringColors.push(c);
        pulseSpeeds.push(0.5 + Math.random() * 1.0);
        ringOffsets.push(0.05 + Math.random() * 0.9); // random spacing from inner to outer
      }

      const uniforms = {
        uRingCount: { value: 8 },
        uRingColors: { value: ringColors.map((c) => new THREE.Vector3(c.r, c.g, c.b)) },
        uLineWidth: { value: 0.008 },
        uNoiseStrength: { value: 0.02 },
        uTime: { value: 0.0 },
        uPulseSpeeds: { value: pulseSpeeds },
        uRingOffsets: { value: ringOffsets },
      };

      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      composer.addPass(
        new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.9,
          0.6,
          0.12,
        ),
      );

      // --- UI ---
      const ringCountEl = document.getElementById('ringCount');
      const rcSpan = document.getElementById('rc');
      ringCountEl.addEventListener('input', (e) => {
        const v = parseInt(e.target.value);
        uniforms.uRingCount.value = v;
        rcSpan.textContent = v;
      });

      const lineWidthEl = document.getElementById('lineWidth');
      const lwSpan = document.getElementById('lw');
      lineWidthEl.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        const mapped = 0.002 + ((v - 1) / (30 - 1)) * (0.02 - 0.002);
        uniforms.uLineWidth.value = mapped;
        lwSpan.textContent = mapped.toFixed(3);
      });

      const noiseEl = document.getElementById('noiseStrength');
      const nsSpan = document.getElementById('ns');
      noiseEl.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        const mapped = (v / 50.0) * 0.06;
        uniforms.uNoiseStrength.value = mapped;
        nsSpan.textContent = mapped.toFixed(3);
      });

      rcSpan.textContent = uniforms.uRingCount.value;
      lwSpan.textContent = uniforms.uLineWidth.value.toFixed(3);
      nsSpan.textContent = uniforms.uNoiseStrength.value.toFixed(3);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      function animate() {
        const t = clock.getElapsedTime();
        uniforms.uTime.value = t;
        mesh.rotation.z = Math.sin(t * 0.12) * 0.08;
        controls.update();
        composer.render();
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener('keydown', (e) => {
        if (e.key === 'g') composer.passes[1].strength = composer.passes[1].strength > 0 ? 0 : 0.9;
      });
    </script>
  </body>
</html>
